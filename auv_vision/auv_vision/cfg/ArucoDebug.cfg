#!/usr/bin/env python
"""
Dynamic reconfigure configuration for ArUco Board Pose Estimator Debug Node.

Parameters are grouped by category:
- Preprocessing: CLAHE and blur settings
- Adaptive Thresholding: ArUco detector threshold parameters
- Marker Detection: Size and shape constraints for marker candidates
- Corner Refinement: Sub-pixel corner localization settings
- PnP Quality: Pose estimation quality thresholds
"""
PACKAGE = "auv_vision"

from dynamic_reconfigure.parameter_generator_catkin import *

gen = ParameterGenerator()

# =============================================================================
# PREPROCESSING
# Image enhancement before marker detection
# =============================================================================
preproc = gen.add_group("Preprocessing")

preproc.add("clahe_clip_limit", double_t, 0,
    "CLAHE contrast limit. Higher values increase local contrast but may amplify noise. "
    "Increase in low-contrast underwater conditions; decrease if image becomes noisy.",
    2.0, 1.0, 10.0)

preproc.add("clahe_tile_size", int_t, 0,
    "CLAHE tile grid size (NxN). Smaller tiles give more local adaptation but can introduce artifacts. "
    "Larger tiles give more uniform enhancement. 8 is a good default for most cases.",
    8, 2, 32)

preproc.add("blur_strength", int_t, 0,
    "Median blur kernel size (must be odd). Reduces noise before detection.",
    3, 1, 15)

# =============================================================================
# ADAPTIVE THRESHOLDING
# Controls how the detector converts grayscale to binary for marker detection
# =============================================================================
thresh = gen.add_group("Adaptive_Thresholding")

thresh.add("adaptive_thresh_win_size_min", int_t, 0,
    "Minimum window size for adaptive thresholding. Smaller values detect finer details "
    "but are more sensitive to noise. Increase if getting false positives from noise.",
    7, 3, 99)

thresh.add("adaptive_thresh_win_size_max", int_t, 0,
    "Maximum window size for adaptive thresholding. Larger values handle uneven lighting better. "
    "Increase in environments with strong lighting gradients (e.g., pool with sun reflections).",
    75, 3, 999)

thresh.add("adaptive_thresh_win_size_step", int_t, 0,
    "Step size between min and max window sizes. Smaller steps try more scales (slower but more robust). "
    "Increase for faster processing; decrease for better detection in difficult lighting.",
    8, 2, 50)

thresh.add("adaptive_thresh_constant", double_t, 0,
    "Constant subtracted from mean in adaptive thresholding. Higher values make the threshold stricter "
    "(darker pixels needed to be considered black). Adjust if markers appear washed out or too dark.",
    5.0, -20.0, 20.0)

# =============================================================================
# MARKER DETECTION
# Constraints on what shapes are considered valid marker candidates
# =============================================================================
detect = gen.add_group("Marker_Detection")

detect.add("min_marker_perimeter_rate", double_t, 0,
    "Minimum marker perimeter as a fraction of image perimeter. Filters out tiny candidates. "
    "Decrease to detect very small/distant markers; increase to reject noise.",
    0.02, 0.001, 0.5)

detect.add("max_marker_perimeter_rate", double_t, 0,
    "Maximum marker perimeter as a fraction of image perimeter. Filters out huge candidates. "
    "Increase if markers can fill most of the frame when very close.",
    4.0, 0.5, 10.0)

detect.add("polygonal_approx_accuracy_rate", double_t, 0,
    "Accuracy for polygonal approximation of contours (relative to perimeter). "
    "Lower values require more precise square shapes; higher values tolerate distortion. "
    "Increase for markers at oblique angles or with lens distortion.",
    0.05, 0.001, 0.2)

detect.add("error_correction_rate", double_t, 0,
    "Maximum fraction of bits that can be corrected in the marker code. "
    "Higher values recover partially occluded/damaged markers but may cause false positives. "
    "Increase in turbid water where markers may be partially obscured.",
    0.6, 0.0, 1.0)

# =============================================================================
# CORNER REFINEMENT
# Sub-pixel corner localization for accurate pose estimation
# =============================================================================
corner = gen.add_group("Corner_Refinement")

corner.add("corner_refinement_win_size", int_t, 0,
    "Window size for sub-pixel corner refinement. Larger windows are more robust to noise "
    "but may average across edges. Increase for noisy images; decrease for sharp, clean images.",
    7, 3, 21)

corner.add("corner_refinement_max_iterations", int_t, 0,
    "Maximum iterations for corner refinement optimization. More iterations give better accuracy "
    "but take longer. 30 is usually sufficient; increase only if corners seem inaccurate.",
    30, 5, 100)

corner.add("corner_refinement_min_accuracy", double_t, 0,
    "Minimum corner position change (pixels) to continue refining. Smaller values give higher precision "
    "but take longer. Decrease for sub-pixel accuracy requirements (e.g., close-range docking).",
    0.05, 0.001, 1.0)

# =============================================================================
# PNP QUALITY
# Pose estimation quality thresholds
# =============================================================================
pnp = gen.add_group("PnP_Quality")


pnp.add("ransac_iterations", int_t, 0,
    "Number of RANSAC iterations for solvePnPRansac. More iterations increase robustness "
    "but take longer. Increase if pose estimation is unstable with outliers.",
    200, 10, 2000)

pnp.add("ransac_reproj_error", double_t, 0,
    "Maximum reprojection error (pixels) for RANSAC inlier classification. "
    "Lower values are stricter (fewer inliers); higher values accept more points. "
    "Increase in noisy conditions or when corners are less accurate.",
    20.0, 1.0, 100.0)

exit(gen.generate(PACKAGE, "aruco_board_estimator", "ArucoDebug"))
