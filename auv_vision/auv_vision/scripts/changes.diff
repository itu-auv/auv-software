diff --git a/auv_vision/auv_vision/scripts/camera_detection_pose_estimator.py b/auv_vision/auv_vision/scripts/camera_detection_pose_estimator.py
index 8e9610de..6740d24e 100644
--- a/auv_vision/auv_vision/scripts/camera_detection_pose_estimator.py
+++ b/auv_vision/auv_vision/scripts/camera_detection_pose_estimator.py
@@ -22,6 +22,7 @@ from auv_msgs.srv import SetDetectionFocus, SetDetectionFocusResponse
 import auv_common_lib.vision.camera_calibrations as camera_calibrations
 import tf2_ros
 import tf2_geometry_msgs
+from tf import transformations as tf_transformations
 from dynamic_reconfigure.client import Client
 
 
@@ -110,6 +111,11 @@ class WhitePipe(Prop):
         super().__init__(3, "white_pipe", 0.90, None)
 
 
+class Bottle(Prop):
+    def __init__(self):
+        super().__init__(0, "bottle", None, 0.09)
+
+
 class TorpedoMap(Prop):
     def __init__(self):
         super().__init__(4, "torpedo_map", 0.6096, 0.6096)
@@ -155,6 +161,9 @@ class CameraDetectionNode:
         self.torpedo_camera_enabled = False
 
         self.red_pipe_x = None
+        self.bottle_angle = None  # Angle of bottle relative to base_link
+        self.current_yaw = 0.0  # Current yaw of base_link in odom frame
+        self.bottle_thickness_px = None  # Pixel width from bottle_angle_node
 
         self.object_id_map = {
             "gate": [0, 1],
@@ -182,7 +191,10 @@ class CameraDetectionNode:
             "taluy/cameras/cam_bottom": CameraCalibration("cameras/cam_bottom"),
             "taluy/cameras/cam_torpedo": CameraCalibration("cameras/cam_torpedo"),
         }
-        # Use lambda to pass camera source information to the callback
+        # Segmentation source uses the same camera calibration as bottom camera
+        self.camera_calibrations["taluy/cameras/cam_bottom_seg"] = (
+            self.camera_calibrations["taluy/cameras/cam_bottom"]
+        )
         rospy.Subscriber(
             "/yolo_result_front",
             YoloResult,
@@ -196,6 +208,9 @@ class CameraDetectionNode:
             queue_size=1,
         )
         rospy.Subscriber(
+            "/yolo_result_seg",
+            YoloResult,
+            lambda msg: self.detection_callback(msg, camera_source="bottom_camera_seg"),
             "/yolo_result_torpedo",
             YoloResult,
             lambda msg: self.detection_callback(msg, camera_source="torpedo_camera"),
@@ -216,6 +231,7 @@ class CameraDetectionNode:
             "gate_shark_link": Shark(),
             "red_pipe_link": RedPipe(),
             "white_pipe_link": WhitePipe(),
+            "bottle_link": Bottle(),
             "torpedo_map_link": TorpedoMap(),
             "octagon_link": Octagon(),
             "bin_sawfish_link": BinShark(),
@@ -235,8 +251,13 @@ class CameraDetectionNode:
                 7: "octagon_link",
             },
             "taluy/cameras/cam_bottom": {
-                0: "bin_shark_link",
+                0: "bottle_link",
                 1: "bin_sawfish_link",
+                2: "red_pipe_link",
+                3: "white_pipe_link",
+            },
+            "taluy/cameras/cam_bottom_seg": {
+                0: "bottle_link",
             },
             "taluy/cameras/cam_torpedo": {
                 5: "torpedo_hole_link",
@@ -247,6 +268,14 @@ class CameraDetectionNode:
         self.pool_depth = rospy.get_param("/env/pool_depth")
         rospy.Subscriber("odom_pressure", Odometry, self.altitude_callback)
 
+        # Subscribe to bottle angle and thickness (relative topics - will be prefixed by namespace)
+        rospy.Subscriber(
+            "bottle_angle", Float32, self.bottle_angle_callback, queue_size=1
+        )
+        rospy.Subscriber(
+            "bottle_thickness", Float32, self.bottle_thickness_callback, queue_size=1
+        )
+
         # Services to enable/disable cameras
         rospy.Service(
             "enable_front_camera_detections",
@@ -339,6 +368,54 @@ class CameraDetectionNode:
             f"Calculated altitude from odom_pressure: {self.altitude:.2f} m (pool_depth={self.pool_depth})"
         )
 
+    def bottle_thickness_callback(self, msg: Float32):
+        print("bottle thickness callback")
+        print(msg.data)
+        """Store bottle thickness in pixels from bottle_angle_node.
+
+        Args:
+            msg: Float32 message containing the bottle thickness in pixels
+        """
+        if not math.isnan(msg.data) and msg.data > 0:
+            self.bottle_thickness_px = msg.data
+            rospy.logdebug(
+                f"Updated bottle thickness: {self.bottle_thickness_px:.1f}px"
+            )
+
+    def bottle_angle_callback(self, msg: Float32):
+        print("bottle angle callback")
+        print(msg.data)
+        """Store bottle angle from bottle_angle_node.
+
+        Args:
+            msg: Float32 message containing the bottle angle in radians relative to base_link
+        """
+        if not math.isnan(msg.data):
+            self.bottle_angle = -msg.data  # Store in base_link frame
+
+            # Get current yaw from odom to base_link transform
+            try:
+                # Get transform from odom to base_link
+                transform = self.tf_buffer.lookup_transform(
+                    "odom", "taluy/base_link", rospy.Time(0), rospy.Duration(1.0)
+                )
+                # Extract yaw from quaternion
+                _, _, self.current_yaw = tf_transformations.euler_from_quaternion(
+                    [
+                        transform.transform.rotation.x,
+                        transform.transform.rotation.y,
+                        transform.transform.rotation.z,
+                        transform.transform.rotation.w,
+                    ]
+                )
+            except (
+                tf2_ros.LookupException,
+                tf2_ros.ConnectivityException,
+                tf2_ros.ExtrapolationException,
+            ) as e:
+                rospy.logwarn(f"Could not get transform from odom to base_link: {e}")
+                return
+
     def calculate_intersection_with_plane(self, point1_odom, point2_odom, z_plane):
         # Calculate t where the z component is z_plane
         if point2_odom.point.z != point1_odom.point.z:
@@ -586,15 +663,21 @@ class CameraDetectionNode:
         return True
 
     def detection_callback(self, detection_msg: YoloResult, camera_source: str):
-        # Determine camera_ns based on the source passed by the subscriber
+        # Determine camera_ns based on the source passed by the subscribe
         if camera_source == "front_camera":
             if not self.front_camera_enabled:
                 return
             camera_ns = "taluy/cameras/cam_front"
         elif camera_source == "bottom_camera":
             if not self.bottom_camera_enabled:
+                rospy.loginfo_throttle(5, "Bottom camera detection is disabled")
                 return
             camera_ns = "taluy/cameras/cam_bottom"
+        elif camera_source == "bottom_camera_seg":
+            if not self.bottom_camera_enabled:
+                rospy.loginfo_throttle(5, "Bottom camera segmentation is disabled")
+                return
+            camera_ns = "taluy/cameras/cam_bottom_seg"
         elif camera_source == "torpedo_camera":
             if not self.torpedo_camera_enabled:
                 return
@@ -603,7 +686,11 @@ class CameraDetectionNode:
             rospy.logerr(f"Unknown camera_source: {camera_source}")
             return  # Stop processing if the source is unknown
 
-        camera_frame = self.camera_frames[camera_ns]
+        # For segmentation source, use the same camera frame as bottom camera
+        if camera_ns == "taluy/cameras/cam_bottom_seg":
+            camera_frame = self.camera_frames["taluy/cameras/cam_bottom"]
+        else:
+            camera_frame = self.camera_frames[camera_ns]
         try:
             camera_to_odom_transform = self.tf_buffer.lookup_transform(
                 camera_frame,
@@ -636,7 +723,6 @@ class CameraDetectionNode:
                 continue
             skip_inside_image = False
             detection_id = detection.results[0].id
-
             if camera_source == "front_camera":
                 if detection_id not in self.active_front_camera_ids:
                     continue
@@ -653,10 +739,43 @@ class CameraDetectionNode:
 
             if detection_id not in self.id_tf_map[camera_ns]:
                 continue
-            if camera_ns == "taluy/cameras/cam_bottom" and detection_id in [0, 1]:
+            prop_name = self.id_tf_map[camera_ns][detection_id]
+            if prop_name not in self.props:
+                continue
+            prop = self.props[prop_name]
+            if camera_ns == "taluy/cameras/cam_bottom" and detection_id in [
+                0,
+                1,
+            ]:  # Bottle detection
                 skip_inside_image = True
-                # use altidude for bin
-                distance = self.altitude
+                # Calculate distance using pixel width from bottle_angle_node
+                if (
+                    self.bottle_thickness_px is not None
+                    and self.bottle_thickness_px > 0
+                ):
+                    # Use the bottle_thickness_px as the width in pixels
+                    distance = prop.estimate_distance(
+                        None,
+                        self.bottle_thickness_px,
+                        self.camera_calibrations[camera_ns],
+                    )
+                    print(str(distance) + "-----distance of bottle ")
+                    rospy.logdebug(
+                        f"Using bottle_thickness_px: {self.bottle_thickness_px}px for distance calculation"
+                    )
+                else:
+                    # Fallback to using bbox width if bottle_thickness_px is not available
+                    distance = prop.estimate_distance(
+                        detection.bbox.size_y,  # height
+                        detection.bbox.size_x,  # width
+                        self.camera_calibrations[camera_ns],
+                    )
+                    print(str(distance) + "-----distance of bottle from wrong tree ")
+                if distance is None:
+                    rospy.logwarn(
+                        "Could not calculate bottle distance from pixel width, using altitude"
+                    )
+                    distance = self.altitude
 
             if detection_id == 6:
                 self.process_altitude_projection(
@@ -666,11 +785,6 @@ class CameraDetectionNode:
             if not skip_inside_image:
                 if self.check_if_detection_is_inside_image(detection) is False:
                     continue
-            prop_name = self.id_tf_map[camera_ns][detection_id]
-            if prop_name not in self.props:
-                continue
-
-            prop = self.props[prop_name]
 
             if not skip_inside_image:  # Calculate distance using object dimensions
                 distance = prop.estimate_distance(
@@ -707,7 +821,20 @@ class CameraDetectionNode:
             transform_stamped_msg.transform.translation = Vector3(
                 offset_x, offset_y, distance
             )
-            transform_stamped_msg.transform.rotation = Quaternion(0, 0, 0, 1)
+
+            # For bottom camera bottle/pipe detections, use bottle angle in odom frame
+            if (
+                camera_ns
+                in ["taluy/cameras/cam_bottom", "taluy/cameras/cam_bottom_seg"]
+                and detection_id in [0, 2, 3]
+                and self.bottle_angle is not None
+            ):
+                # Calculate angle in odom frame: bottle_angle_odom = current_yaw + bottle_angle_base_link
+                bottle_angle_odom = self.current_yaw + self.bottle_angle
+                quat = tf_transformations.quaternion_from_euler(0, 0, bottle_angle_odom)
+                transform_stamped_msg.transform.rotation = Quaternion(*quat)
+            else:
+                transform_stamped_msg.transform.rotation = Quaternion(0, 0, 0, 1)
 
             try:
                 # Create a PoseStamped message from the TransformStamped
